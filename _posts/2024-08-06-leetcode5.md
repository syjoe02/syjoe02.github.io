---
title: Every Weekday_(08.05 ~ 08.09)
author: syJoe
date: 2024-08-05 09:00:00 +0800
categories: [Review]
tags: [c++, python]
comments: true
---

# Roman to Integer

```c++
class Solution {
public:
    int romanToInt(string s) {
        std::unordered_map<char, int> roman_to_int = {
            {'I', 1},
            {'V', 5},
            {'X', 10},
            {'L', 50},
            {'C', 100},
            {'D', 500},
            {'M', 1000}
        };
        int total = 0;
        int temp = 0;

        for (auto item = s.rbegin(); item != s.rend(); ++item) {
            int value = roman_to_int[*item];

            if (value < temp) {
                total -= value;
            } else {
                total += value;
            }
            temp = value;
        }
        return total;
    }
};
```

### Reviews

1. int value = roman_to_int[*item] : Dereferencing

- `*` operator is used to dereference an iterator

- Map Access: roman_to_int[*it] uses the character obtained from dereferencing the iterator as the  key to access the corresponding value in the unordered_map.

- Example Without Dereferencing:

    - Imagine it as a bookmark in a book (the iterator)

    - *it is the actual page where the bookmark is placed (the character in the string)

    - You need the page (character) to look up information in a map, not the bookmark itself

2. `auto` keyword

- allow the compiler to automatically deduce the type of a variable from its initializer

- If I didn't use `auto`, then

    ```c++
    for (std::string::reverse_iterator item = s.rbegin(); item != s.rend(); ++item)
    ```

    - So, This keyword makes the code more readable by reducing clutter

# Combined of Pointers

```c++
#include <iostream>

int main() {
    int a = 10;        // Normal variable
    int *p = &a;       // Pointer variable, holding the address of 'a'

    std::cout << "Address of a (reference): " << &a << std::endl;
    std::cout << "Value of p (address of a): " << p << std::endl;
    std::cout << "Value of a: " << a << std::endl;
    std::cout << "Value of *p (dereference p): " << *p << std::endl;

    // Changing the value using the pointer
    *p = 20;
    std::cout << "New value of a after *p = 20: " << a << std::endl;

    return 0;
}

```

### Reviews

1. reference(`&`) AND dereference(`*`)

- `&a` is the reference to `a`, giving us its address

- `*p` is the dereference of `p`, giving us the value stored at the address `p` holds, which is the value of `a`
