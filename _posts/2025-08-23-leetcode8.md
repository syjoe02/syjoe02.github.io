---
title: "[LeetCode] 2762. Continuous Subarrays"
author: syJoe
date: 2024-12-15 09:00:00 +0800
categories: [LeetCode]
tags: [algorithm, c++]
description: "In this post, we will solve the problem of counting continuous subarrays where the difference between the maximum and minimum values is at most 2. Starting from a naive approach with O(n^2) complexity, we optimize it to O(n) using a sliding window combined with two deques."
---

# Continuous Subarrays

- [Leetcode Website](https://leetcode.com/problems/continuous-subarrays/description/)

- Let i, i + 1, ..., j be the indices in the subarray

    Then, for each pair of indices i <= i1, i2 <= j, `0 <= |nums[i1] - nums[i2]| <= 2`

    ![Alt text](../assets/img/blog/leetcode8.png)

# Step by Step Optimization (C++)

1. Brute Force

    If `max - min > 2`, break â†’ otherwise, count subarray

2. Optimization

    sliding window, monotonic deques

3. Other ways


## 1. Brute Force

- simple and intuitive. but inefficient

- Code (C++)

    ```c++
    #include <iostream>
    #include <vector>
    #include <algorithm>
    using namespace std;

    int countSubarraysBruteForce(vector<int>& nums) {
        int n = nums.size();
        int total = 0;

        for (int i = 0; i < n; i++) {
            int mx = nums[i], mn = nums[i];
            for (int j = i; j < n; j++) {
                mx = max(mx, nums[j]);
                mn = min(mn, nums[j]);
                if (mx - mn > 2) break;
                total++;
            }
        }
        return total;
    }

    int main() {
        vector<int> nums = {5, 4, 2, 4};
        cout << countSubarraysBruteForce(nums) << endl;
    }
    ```

- Time Complexity : O(n^2)

- Space Complexity : `O(1)`

    Only uses a few scalar variables (mx, mn, total, i, j). Therefore, no matter how large n is, the memory usage stays constant

## 2. Optimized

- maintain the max and min values efficicently with two deques (maxQ, minQ)

- Code (C++)

    ```c++
    #include <iostream>
    #include <vector>
    #include <deque>
    using namespace std;

    int countSubarraysOptimized(vector<int>& nums) {
        int n = nums.size();
        int total = 0;
        int left = 0;
        deque<int> maxQ, minQ;

        for (int right = 0; right < n; right++) {
            while (!maxQ.empty() && nums[maxQ.back()] <= nums[right]) {
                maxQ.pop_back();
            }
            maxQ.push_back(right);

            while (!minQ.empty() && nums[minQ.back()] >= nums[right]) {
                minQ.pop_back();
            }
            minQ.push_back(right);

            while (nums[maxQ.front()] - nums[minQ.front()] > 2) {
                if (maxQ.front() == left) maxQ.pop_front();
                if (minQ.front() == left) minQ.pop_front();
                left++;
            }
            total += (right - left + 1);
        }
        return total;
    }

    int main() {
        vector<int> nums1 = {5, 4, 2, 4};
        vector<int> nums2 = {1, 2, 3};

        cout << countSubarraysOptimized(nums1) << endl;
        cout << countSubarraysOptimized(nums2) << endl;
    }
    ```

- deque

    maxQ : indices of elements in decreasing order [`front = max`, back = min]

    minQ : indices of elements in increasing order [`front = min`, back = max]

- Time Complexity : O(n)

- Space Complexity : O(n)
